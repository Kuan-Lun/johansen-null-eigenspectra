mod brownian_motion_test;

// 标准正态分布的分位数和期望CDF值，供所有测试共享
pub const STANDARD_NORMAL_QUANTILES: &[f64] = &[
    -2.3263478740408408,
    -2.053748910631823,
    -1.880793608151251,
    -1.75068607125217,
    -1.6448536269514729,
    -1.5547735945968535,
    -1.4757910281791706,
    -1.4050715603096329,
    -1.3407550336902165,
    -1.2815515655446004,
    -1.2265281200366098,
    -1.1749867920660904,
    -1.1263911290388007,
    -1.0803193408149558,
    -1.0364333894937898,
    -0.994457883209753,
    -0.9541652531461943,
    -0.915365087842814,
    -0.8778962950512288,
    -0.8416212335729142,
    -0.8064212470182404,
    -0.7721932141886848,
    -0.7388468491852137,
    -0.7063025628400874,
    -0.6744897501960817,
    -0.643345405392917,
    -0.6128129910166272,
    -0.5828415072712162,
    -0.5533847195556729,
    -0.5244005127080409,
    -0.4958503473474533,
    -0.46769879911450823,
    -0.4399131656732338,
    -0.41246312944140473,
    -0.38532046640756773,
    -0.3584587932511938,
    -0.33185334643681663,
    -0.3054807880993974,
    -0.27931903444745415,
    -0.2533471031357997,
    -0.22754497664114948,
    -0.20189347914185088,
    -0.17637416478086135,
    -0.15096921549677725,
    -0.12566134685507402,
    -0.10043372051146975,
    -0.0752698620998299,
    -0.05015358346473367,
    -0.02506890825871106,
    0.0,
    0.02506890825871106,
    0.05015358346473367,
    0.0752698620998299,
    0.10043372051146988,
    0.12566134685507416,
    0.1509692154967774,
    0.1763741647808612,
    0.20189347914185074,
    0.22754497664114934,
    0.2533471031357997,
    0.27931903444745415,
    0.3054807880993974,
    0.33185334643681663,
    0.3584587932511938,
    0.38532046640756773,
    0.41246312944140495,
    0.4399131656732339,
    0.4676987991145084,
    0.4958503473474532,
    0.5244005127080407,
    0.5533847195556727,
    0.5828415072712162,
    0.6128129910166272,
    0.643345405392917,
    0.6744897501960817,
    0.7063025628400874,
    0.7388468491852137,
    0.7721932141886848,
    0.8064212470182404,
    0.8416212335729143,
    0.8778962950512289,
    0.9153650878428138,
    0.9541652531461943,
    0.994457883209753,
    1.0364333894937898,
    1.0803193408149558,
    1.1263911290388007,
    1.1749867920660904,
    1.2265281200366105,
    1.2815515655446004,
    1.3407550336902165,
    1.4050715603096329,
    1.475791028179171,
    1.5547735945968535,
    1.6448536269514722,
    1.7506860712521692,
    1.8807936081512509,
    2.0537489106318225,
    2.3263478740408408,
];

pub const STANDARD_NORMAL_EXPECTED_CDF: &[f64] = &[
    0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16,
    0.17, 0.18, 0.19, 0.20, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.30, 0.31, 0.32,
    0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48,
    0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64,
    0.65, 0.66, 0.67, 0.68, 0.69, 0.70, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.80,
    0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96,
    0.97, 0.98, 0.99,
];

pub fn assert_vec_approx_eq(a: &[f64], b: &[f64], eps: f64) {
    assert_eq!(
        a.len(),
        b.len(),
        "Length mismatch: {} vs {}",
        a.len(),
        b.len()
    );
    for (i, (opt, val)) in a.iter().zip(b.iter()).enumerate() {
        assert!(
            (opt - val).abs() < eps,
            "Values at index {} differ: {} vs {} (eps: {})",
            i,
            opt,
            val,
            eps
        );
    }
}

pub fn interpolated_cdf_sorted(data_sorted: &[f64], query_sorted: &[f64]) -> Vec<f64> {
    let n = data_sorted.len();
    let m = query_sorted.len();
    if n == 0 {
        return vec![f64::NAN; m];
    }

    let mut result = Vec::with_capacity(m);
    let mut i = 0;
    for &x in query_sorted {
        if x <= data_sorted[0] {
            result.push(0.0);
            continue;
        }
        if x >= data_sorted[n - 1] {
            result.push(1.0);
            continue;
        }
        while i + 1 < n && data_sorted[i + 1] <= x {
            i += 1;
        }
        let x0 = data_sorted[i];
        let x1 = data_sorted[i + 1];
        let cdf0 = i as f64 / n as f64;
        let cdf1 = (i + 1) as f64 / n as f64;
        let weight = (x - x0) / (x1 - x0);
        let cdf = cdf0 * (1.0 - weight) + cdf1 * weight;
        result.push(cdf);
    }
    result
}
