# Performance Guidelines

本文件為效能最佳化相關的 AI Agent 提供詳細指導。

## 效能分析

### 效能測量工具

- 使用 `cargo bench` 進行基準測試
- 使用 `perf` 進行系統級效能分析
- 使用 `valgrind` 檢查記憶體使用
- 使用 `flamegraph` 生成火焰圖

### 關鍵效能指標

- 計算時間複雜度
- 記憶體使用效率
- 快取命中率
- 並行效能表現

## 最佳化策略

### 演算法最佳化

#### 矩陣運算最佳化

- 使用高效的 BLAS 程式庫
- 避免不必要的記憶體分配
- 利用矩陣的特殊性質（對稱、稀疏等）
- 選擇適當的數值演算法

#### 數值計算最佳化

- 使用穩定的數值演算法
- 避免數值溢位和下溢
- 合理選擇浮點精度
- 預計算常用值

### 記憶體管理最佳化

#### 記憶體分配策略

- 預分配大塊記憶體
- 重用臨時物件
- 使用記憶體池技術
- 避免頻繁的小記憶體分配

#### 資料結構選擇

- 選擇記憶體局部性好的資料結構
- 使用快取友好的資料佈局
- 考慮資料壓縮技術
- 最佳化資料對齊

### 並行最佳化

#### 執行緒安全和效能

- 減少鎖的粒度和持有時間
- 使用無鎖資料結構
- 合理設計並行演算法
- 避免假共享

#### 任務分解

- 合理劃分計算任務
- 平衡負載分配
- 減少執行緒間通訊開銷
- 最佳化資料依賴關係

## 特定場景最佳化

### Monte Carlo 模擬最佳化

#### 隨機數生成最佳化

- 使用高品質的隨機數生成器
- 批量生成隨機數
- 利用向量化指令
- 減少隨機數呼叫次數

#### 模擬迴圈最佳化

- 展開迴圈減少分支
- 使用 SIMD 指令並行化
- 預計算可重用的值
- 最佳化記憶體存取模式

### 特徵值計算最佳化

#### 演算法選擇

- 針對矩陣特性選擇演算法
- 使用迭代演算法適應大矩陣
- 利用稀疏性質
- 考慮近似演算法的適用性

#### 數值穩定性

- 使用數值穩定的分解方法
- 實作適當的預處理
- 控制迭代收斂條件
- 處理特殊情況

## 效能測試

### 基準測試設計

#### 測試用例設計

- 覆蓋典型使用場景
- 包含極端情況測試
- 使用真實資料規模
- 控制測試環境變數

#### 效能回歸檢測

- 建立效能基線
- 自動化效能測試
- 設定效能警報閾值
- 追蹤長期效能趨勢

### 效能分析方法

#### 熱點分析

- 識別計算瓶頸
- 分析函數呼叫頻率
- 檢查記憶體存取模式
- 評估 I/O 操作影響

#### 可擴展性分析

- 測試不同資料規模下的效能
- 評估並行擴展性
- 分析記憶體擴展性
- 檢查演算法複雜度實際表現

## 編譯器最佳化

### 編譯選項

```toml
[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
```

### 目標特定最佳化

- 使用 `-C target-cpu=native`
- 啟用特定 CPU 特性
- 考慮交叉編譯最佳化
- 利用硬體加速指令

## 效能監控

### 執行時監控

#### 效能指標收集

- CPU 使用率
- 記憶體使用情況
- 快取命中率
- 系統呼叫開銷

#### 效能日誌

- 記錄關鍵操作的耗時
- 監控記憶體分配情況
- 追蹤並行操作效能
- 收集錯誤和異常資訊

### 持續效能最佳化

#### 效能目標設定

- 定義明確的效能指標
- 設定可達成的效能目標
- 建立效能改進路線圖
- 定期評估效能表現

#### 最佳化驗證

- 驗證最佳化的有效性
- 檢查最佳化的副作用
- 確保數值準確性不受影響
- 測試在不同環境下的表現

## 特殊注意事項

### 數值精度與效能平衡

- 在精度要求和效能之間找到平衡
- 使用適當的數值類型
- 考慮近似演算法的精度損失
- 驗證最佳化對結果準確性的影響

### 跨平台效能

- 考慮不同平台的效能特性
- 測試在各種硬體設定下的表現
- 適配不同的編譯器最佳化
- 處理平台特定的效能問題
